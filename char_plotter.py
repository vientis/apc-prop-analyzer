#!/usr/bin/env python3
"""
Propeller Characteristic Plotter

This script visualizes propeller performance characteristics by loading data from
pickle files generated by characteristic_generator.py.

Plot Types:
1. RPM Sweep: Thrust, Torque, and Shaft Power vs RPM at a specific flight speed
2. J Sweep: CT, CP, and Efficiency vs Advance Ratio (J) at a specific RPM

Usage:
    python char_plotter.py
    
The script will prompt for:
- Propeller identifier (e.g., D10P12B2TWE)
- Plot type (RPM sweep or J sweep)
- Additional parameters based on plot type
"""

import os
import pickle
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import glob
from abc import ABC, abstractmethod


class PropellerDataManager:
    """Manages loading and accessing propeller data from pickle files."""
    
    @staticmethod
    def find_available_propellers():
        """Find all available propeller pickle files."""
        pickle_files = glob.glob('reformatted_data/full-characteristics/APC_Prop_*.pickle')
        propellers = []
        for file in pickle_files:
            filename = os.path.basename(file)
            prop_name = filename.replace('APC_Prop_', '').replace('.pickle', '')
            propellers.append(prop_name)
        return sorted(propellers)
    
    @staticmethod
    def load_propeller_data(propeller_name):
        """Load propeller data from pickle file."""
        filename = f'reformatted_data/full-characteristics/APC_Prop_{propeller_name}.pickle'
        
        if not os.path.exists(filename):
            return None
        
        try:
            with open(filename, 'rb') as f:
                data = pickle.load(f)
            return data
        except Exception as e:
            print(f"Error loading data: {e}")
            return None
    
    @staticmethod
    def find_closest_value(data, target_value):
        """Find the closest available value in data keys."""
        available_values = list(data.keys())
        closest_value = min(available_values, key=lambda x: abs(x - target_value))
        return closest_value
    
    @staticmethod
    def extract_propeller_diameter(propeller_name):
        """Extract propeller diameter in inches from propeller name."""
        try:
            if 'D' in propeller_name and 'P' in propeller_name:
                diameter_string = propeller_name.split('P')[0][1:]
                if '-' in diameter_string:
                    diameter = float(diameter_string.replace('-', '.'))
                else:
                    diameter = float(diameter_string)
                return diameter
        except (ValueError, IndexError):
            pass
        return None
    
    @staticmethod
    def calculate_max_mechanical_rpm(diameter_inches):
        """Calculate maximum mechanical RPM for APC propellers."""
        if diameter_inches and diameter_inches > 0:
            return int(190000 / diameter_inches)
        return None
    
    @staticmethod
    def get_available_rpms(data):
        """Get all unique RPM values from the data."""
        rpms = set()
        for speed_data in data.values():
            rpms.update(speed_data['rpm'].values)
        return sorted([rpm for rpm in rpms if rpm > 0])


class PlotUtilities:
    """Utility functions for plotting."""
    
    @staticmethod
    def second_order_polynomial(x, a, b, c):
        """Second order polynomial function for curve fitting."""
        return a * x**2 + b * x + c
    
    @staticmethod
    def third_order_polynomial(x, a, b, c, d):
        """Third order polynomial function for curve fitting."""
        return a * x**3 + b * x**2 + c * x + d
    
    @staticmethod
    def calculate_label_offsets(valid_refs, ref_range):
        """Calculate vertical offsets for reference markers to prevent overlap."""
        if len(valid_refs) <= 1:
            return [(ref, 15) for ref in valid_refs]
        
        sorted_refs = sorted(valid_refs)
        range_span = ref_range[1] - ref_range[0]
        label_offsets = []
        offset_levels = [15, 45, 75, 25, 55, 85]
        
        for i, ref_val in enumerate(sorted_refs):
            needs_offset = False
            
            if i > 0:
                prev_ref = sorted_refs[i-1]
                horizontal_distance = (ref_val - prev_ref) / range_span
                if horizontal_distance < 0.20:
                    needs_offset = True
            
            if i < len(sorted_refs) - 1:
                next_ref = sorted_refs[i+1]
                horizontal_distance = (next_ref - ref_val) / range_span
                if horizontal_distance < 0.20:
                    needs_offset = True
            
            if needs_offset:
                base_offset = offset_levels[i % len(offset_levels)]
            else:
                base_offset = offset_levels[i % 2]
            
            label_offsets.append((ref_val, base_offset))
        
        return label_offsets


class BasePlotter(ABC):
    """Abstract base class for different plot types."""
    
    def __init__(self, data, propeller_name):
        self.data = data
        self.propeller_name = propeller_name
        self.diameter_inches = PropellerDataManager.extract_propeller_diameter(propeller_name)
        self.max_mechanical_rpm = PropellerDataManager.calculate_max_mechanical_rpm(self.diameter_inches)
    
    @abstractmethod
    def create_plot(self, save_plot=False, output_dir=None, reference_values=None):
        """Create the plot. Must be implemented by subclasses."""
        pass
    
    @abstractmethod
    def get_plot_filename(self):
        """Get the filename for saving the plot."""
        pass
    
    def save_or_show_plot(self, fig, save_plot, output_dir):
        """Save the plot to file or display it."""
        if save_plot:
            if output_dir is None:
                output_dir = 'output_plots'
            
            os.makedirs(output_dir, exist_ok=True)
            filename = self.get_plot_filename()
            filepath = os.path.join(output_dir, filename)
            
            fig.savefig(filepath, dpi=150, bbox_inches='tight')
            print(f"Plot saved as: {filepath}")
            plt.close()
        else:
            plt.show()


class RPMSweepPlotter(BasePlotter):
    """Plotter for Thrust/Torque/Power vs RPM at a specific flight speed."""
    
    def __init__(self, data, propeller_name, flight_speed):
        super().__init__(data, propeller_name)
        self.flight_speed = flight_speed
    
    def get_plot_filename(self):
        return f'propeller_characteristics_{self.propeller_name}_{self.flight_speed}ms.png'
    
    def create_plot(self, save_plot=False, output_dir=None, reference_rpms=None):
        """Create plots of Thrust vs RPM, Torque vs RPM, and Power vs RPM."""
        speed_data = self.data[self.flight_speed]
        
        rpm = speed_data['rpm'].values
        thrust = speed_data['T'].values
        torque = speed_data['Q'].values
        power = speed_data['P'].values
        
        # TODO: TEMPORARY FIX - Remove this once input data is cleaned up
        # Reduce max RPM by 1000 to avoid anomalies in high-RPM data for 10 inch props
        effective_max_rpm = self.max_mechanical_rpm - 1000 if self.max_mechanical_rpm else None
        
        if effective_max_rpm:
            print(f"Propeller diameter: {self.diameter_inches} inches")
            print(f"Max mechanical RPM limit for curve fitting: {effective_max_rpm} RPM (reduced by 1000 due to data anomalies)")
        
        # Find first meaningful positive thrust for fitting
        # Need to handle non-monotonic data in the transition region
        thrust_threshold = 0.1  # Newtons - threshold for meaningful thrust
        
        # Find candidates that exceed threshold
        significant_thrust_indices = np.where((rpm > 0) & (thrust > thrust_threshold))[0]
        
        if len(significant_thrust_indices) > 0:
            # Check for consistently increasing thrust after each candidate
            # This handles cases where thrust has spurious high values followed by drops
            first_positive_idx = None
            
            for candidate_idx in significant_thrust_indices:
                # Look ahead at next 2 points to verify thrust is consistently above threshold
                look_ahead = min(2, len(thrust) - candidate_idx - 1)
                
                if look_ahead >= 2:
                    # Check the next 2 consecutive points
                    next_1 = thrust[candidate_idx + 1]
                    next_2 = thrust[candidate_idx + 2]
                    
                    # All three consecutive points (current + next 2) must be above threshold
                    if next_1 > thrust_threshold and next_2 > thrust_threshold:
                        first_positive_idx = candidate_idx
                        break
                elif look_ahead == 1:
                    # Near end, check if next point is also above threshold
                    next_1 = thrust[candidate_idx + 1]
                    if next_1 > thrust_threshold:
                        first_positive_idx = candidate_idx
                        break
                else:
                    # At the very end, just use it
                    first_positive_idx = candidate_idx
                    break
            
            # If no consistent region found, use fallback strategies
            if first_positive_idx is None and len(significant_thrust_indices) > 0:
                # Try using a point where subsequent values are all positive (not necessarily above threshold)
                for candidate_idx in significant_thrust_indices:
                    if candidate_idx < len(thrust) - 2:
                        # Check if next 2 points have positive thrust
                        if thrust[candidate_idx + 1] > 0 and thrust[candidate_idx + 2] > 0:
                            first_positive_idx = candidate_idx
                            break
                
                # Last resort: use the point with most remaining above-threshold values
                if first_positive_idx is None:
                    best_candidate = None
                    best_score = 0
                    for candidate_idx in significant_thrust_indices:
                        remaining_above = np.sum(thrust[candidate_idx:] > thrust_threshold)
                        if remaining_above > best_score:
                            best_score = remaining_above
                            best_candidate = candidate_idx
                    first_positive_idx = best_candidate
            
            if first_positive_idx is not None:
                first_positive_rpm = rpm[first_positive_idx]
                print(f"First reliable positive thrust (>{thrust_threshold}N) at RPM: {first_positive_rpm} (index {first_positive_idx})")
                
                # Count excluded points
                excluded_points = np.sum((rpm > 0) & (rpm < first_positive_rpm))
                if excluded_points > 0:
                    print(f"Excluding {excluded_points} data points with zero/negative/unreliable thrust (RPM 1000-{first_positive_rpm-1000:.0f})")
                
                if effective_max_rpm:
                    fitting_mask = (rpm >= first_positive_rpm) & (rpm <= effective_max_rpm)
                    print(f"Fitting data from {first_positive_rpm} RPM to {effective_max_rpm} RPM")
                else:
                    fitting_mask = rpm >= first_positive_rpm
                    print("Warning: Could not determine propeller diameter. Using data from first positive thrust onward.")
                
                # For plotting purposes, use indices from first_positive_idx onward
                positive_thrust_indices = np.where((rpm >= first_positive_rpm) & (thrust > 0))[0]
            else:
                # Fallback
                positive_thrust_indices = np.where((rpm > 0) & (thrust > 0))[0]
                fitting_mask = rpm > 0
                print("Warning: Could not find reliable thrust region. Using all positive data.")
        else:
            # Fallback: try lower threshold or use all positive thrust
            positive_thrust_indices = np.where((rpm > 0) & (thrust > 0))[0]
            if len(positive_thrust_indices) > 0:
                first_positive_idx = positive_thrust_indices[0]
                first_positive_rpm = rpm[first_positive_idx]
                print(f"Note: Using lower threshold - First positive thrust at RPM: {first_positive_rpm}")
                if effective_max_rpm:
                    fitting_mask = (rpm >= first_positive_rpm) & (rpm <= effective_max_rpm)
                else:
                    fitting_mask = rpm >= first_positive_rpm
            else:
                positive_thrust_indices = np.array([], dtype=int)
                fitting_mask = rpm > 0
                print("Warning: No positive thrust values found. Using all non-zero RPM data for fitting.")
        
        rpm_fit = rpm[fitting_mask]
        thrust_fit = thrust[fitting_mask]
        torque_fit = torque[fitting_mask]
        power_fit = power[fitting_mask]
        
        fitting_points = np.sum(fitting_mask)
        total_points = len(rpm)
        print(f"Using {fitting_points}/{total_points} data points for curve fitting")
        
        # Create figure
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))
        fig.suptitle(f'Propeller Characteristics: {self.propeller_name}\nFlight Speed: {self.flight_speed} m/s', 
                     fontsize=14, fontweight='bold')
        
        # Plot thrust, torque, and power
        popt_thrust = self._plot_thrust(ax1, rpm, thrust, rpm_fit, thrust_fit, positive_thrust_indices, reference_rpms, effective_max_rpm)
        popt_torque = self._plot_torque(ax2, rpm, torque, rpm_fit, torque_fit, positive_thrust_indices, reference_rpms, effective_max_rpm)
        popt_power = self._plot_power(ax3, rpm, power, rpm_fit, power_fit, positive_thrust_indices, reference_rpms, effective_max_rpm)
        
        plt.tight_layout()
        self.save_or_show_plot(fig, save_plot, output_dir)
    
    def _plot_thrust(self, ax, rpm, thrust, rpm_fit, thrust_fit, positive_thrust_indices, reference_rpms, effective_max_rpm):
        """Plot Thrust vs RPM."""
        zero_rpm_mask = rpm == 0
        
        if len(positive_thrust_indices) > 0:
            first_positive_rpm = rpm[positive_thrust_indices[0]]
            fitted_data_mask = (rpm >= first_positive_rpm)
            if effective_max_rpm:
                fitted_data_mask = fitted_data_mask & (rpm <= effective_max_rpm)
                extrapolated_mask = rpm > effective_max_rpm
            else:
                extrapolated_mask = np.zeros_like(rpm, dtype=bool)
            
            truncated_mask = (rpm > 0) & (rpm < first_positive_rpm) & (thrust == 0)
            display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
            
            if np.any(display_fitted_mask):
                if effective_max_rpm:
                    ax.scatter(rpm[display_fitted_mask], thrust[display_fitted_mask], alpha=0.8, color='blue', s=30,
                             label=f'Fitted data ({first_positive_rpm:.0f}-{effective_max_rpm} RPM)')
                else:
                    ax.scatter(rpm[display_fitted_mask], thrust[display_fitted_mask], alpha=0.8, color='blue', s=30,
                             label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')
            
            if effective_max_rpm and np.any(extrapolated_mask):
                ax.scatter(rpm[extrapolated_mask], thrust[extrapolated_mask], alpha=0.5, color='lightblue', s=30,
                         label=f'Extrapolated data (>{effective_max_rpm} RPM)')
        else:
            non_zero_mask = rpm > 0
            if np.any(non_zero_mask):
                ax.scatter(rpm[non_zero_mask], thrust[non_zero_mask], alpha=0.6, color='blue', s=30,
                         label='Data points')
        
        popt_thrust = None
        try:
            if len(rpm_fit) >= 3:
                popt_thrust, _ = curve_fit(PlotUtilities.second_order_polynomial, rpm_fit, thrust_fit)
                rpm_smooth = np.linspace(rpm_fit.min(), rpm_fit.max(), 200)
                thrust_smooth = PlotUtilities.second_order_polynomial(rpm_smooth, *popt_thrust)
                ax.plot(rpm_smooth, thrust_smooth, 'r-', linewidth=2, 
                       label=f'2nd Order Fit: T = {popt_thrust[0]:.2e}×RPM² + {popt_thrust[1]:.2e}×RPM + {popt_thrust[2]:.2f}')
        except Exception as e:
            print(f"Could not fit thrust curve: {e}")
        
        if reference_rpms and popt_thrust is not None:
            valid_rpms = [r for r in reference_rpms if rpm_fit.min() <= r <= rpm_fit.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_rpms, (rpm_fit.min(), rpm_fit.max()))
            
            for ref_rpm, y_offset in label_offsets:
                thrust_value = PlotUtilities.second_order_polynomial(ref_rpm, *popt_thrust)
                ax.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'T = {thrust_value:.1f}N @ {ref_rpm:.0f} RPM', 
                          xy=(ref_rpm, thrust_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('RPM')
        ax.set_ylabel('Thrust (N)')
        ax.set_title('Thrust vs RPM')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        return popt_thrust
    
    def _plot_torque(self, ax, rpm, torque, rpm_fit, torque_fit, positive_thrust_indices, reference_rpms, effective_max_rpm):
        """Plot Torque vs RPM."""
        zero_rpm_mask = rpm == 0
        
        if len(positive_thrust_indices) > 0:
            first_positive_rpm = rpm[positive_thrust_indices[0]]
            fitted_data_mask = (rpm >= first_positive_rpm)
            if effective_max_rpm:
                fitted_data_mask = fitted_data_mask & (rpm <= effective_max_rpm)
                extrapolated_mask = rpm > effective_max_rpm
            else:
                extrapolated_mask = np.zeros_like(rpm, dtype=bool)
            
            thrust = self.data[self.flight_speed]['T'].values
            truncated_mask = (rpm > 0) & (rpm < first_positive_rpm) & (thrust == 0)
            display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
            
            if np.any(display_fitted_mask):
                if effective_max_rpm:
                    ax.scatter(rpm[display_fitted_mask], torque[display_fitted_mask], alpha=0.8, color='green', s=30,
                             label=f'Fitted data ({first_positive_rpm:.0f}-{effective_max_rpm} RPM)')
                else:
                    ax.scatter(rpm[display_fitted_mask], torque[display_fitted_mask], alpha=0.8, color='green', s=30,
                             label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')
            
            if effective_max_rpm and np.any(extrapolated_mask):
                ax.scatter(rpm[extrapolated_mask], torque[extrapolated_mask], alpha=0.5, color='lightgreen', s=30,
                         label=f'Extrapolated data (>{effective_max_rpm} RPM)')
        else:
            non_zero_mask = rpm > 0
            if np.any(non_zero_mask):
                ax.scatter(rpm[non_zero_mask], torque[non_zero_mask], alpha=0.6, color='green', s=30,
                         label='Data points')
        
        popt_torque = None
        try:
            if len(rpm_fit) >= 3:
                popt_torque, _ = curve_fit(PlotUtilities.second_order_polynomial, rpm_fit, torque_fit)
                rpm_smooth = np.linspace(rpm_fit.min(), rpm_fit.max(), 200)
                torque_smooth = PlotUtilities.second_order_polynomial(rpm_smooth, *popt_torque)
                ax.plot(rpm_smooth, torque_smooth, 'r-', linewidth=2,
                       label=f'2nd Order Fit: Q = {popt_torque[0]:.2e}×RPM² + {popt_torque[1]:.2e}×RPM + {popt_torque[2]:.2f}')
        except Exception as e:
            print(f"Could not fit torque curve: {e}")
        
        if reference_rpms and popt_torque is not None:
            valid_rpms = [r for r in reference_rpms if rpm_fit.min() <= r <= rpm_fit.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_rpms, (rpm_fit.min(), rpm_fit.max()))
            
            for ref_rpm, y_offset in label_offsets:
                torque_value = PlotUtilities.second_order_polynomial(ref_rpm, *popt_torque)
                ax.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'Q = {torque_value:.3f}Nm @ {ref_rpm:.0f} RPM', 
                          xy=(ref_rpm, torque_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('RPM')
        ax.set_ylabel('Torque (Nm)')
        ax.set_title('Torque vs RPM')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        return popt_torque
    
    def _plot_power(self, ax, rpm, power, rpm_fit, power_fit, positive_thrust_indices, reference_rpms, effective_max_rpm):
        """Plot Power vs RPM."""
        zero_rpm_mask = rpm == 0
        
        if len(positive_thrust_indices) > 0:
            first_positive_rpm = rpm[positive_thrust_indices[0]]
            fitted_data_mask = (rpm >= first_positive_rpm)
            if effective_max_rpm:
                fitted_data_mask = fitted_data_mask & (rpm <= effective_max_rpm)
                extrapolated_mask = rpm > effective_max_rpm
            else:
                extrapolated_mask = np.zeros_like(rpm, dtype=bool)
            
            thrust = self.data[self.flight_speed]['T'].values
            truncated_mask = (rpm > 0) & (rpm < first_positive_rpm) & (thrust == 0)
            display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
            
            if np.any(display_fitted_mask):
                if effective_max_rpm:
                    ax.scatter(rpm[display_fitted_mask], power[display_fitted_mask], alpha=0.8, color='orange', s=30,
                             label=f'Fitted data ({first_positive_rpm:.0f}-{effective_max_rpm} RPM)')
                else:
                    ax.scatter(rpm[display_fitted_mask], power[display_fitted_mask], alpha=0.8, color='orange', s=30,
                             label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')
            
            if effective_max_rpm and np.any(extrapolated_mask):
                ax.scatter(rpm[extrapolated_mask], power[extrapolated_mask], alpha=0.5, color='moccasin', s=30,
                         label=f'Extrapolated data (>{effective_max_rpm} RPM)')
        else:
            non_zero_mask = rpm > 0
            if np.any(non_zero_mask):
                ax.scatter(rpm[non_zero_mask], power[non_zero_mask], alpha=0.6, color='orange', s=30,
                         label='Data points')
        
        popt_power = None
        try:
            if len(rpm_fit) >= 4:
                popt_power, _ = curve_fit(PlotUtilities.third_order_polynomial, rpm_fit, power_fit)
                rpm_smooth = np.linspace(rpm_fit.min(), rpm_fit.max(), 200)
                power_smooth = PlotUtilities.third_order_polynomial(rpm_smooth, *popt_power)
                ax.plot(rpm_smooth, power_smooth, 'r-', linewidth=2,
                       label=f'3rd Order Fit: P = {popt_power[0]:.2e}×RPM³ + {popt_power[1]:.2e}×RPM² + {popt_power[2]:.2e}×RPM + {popt_power[3]:.2f}')
        except Exception as e:
            print(f"Could not fit power curve: {e}")
        
        if reference_rpms and popt_power is not None:
            valid_rpms = [r for r in reference_rpms if rpm_fit.min() <= r <= rpm_fit.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_rpms, (rpm_fit.min(), rpm_fit.max()))
            
            for ref_rpm, y_offset in label_offsets:
                power_value = PlotUtilities.third_order_polynomial(ref_rpm, *popt_power)
                ax.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'P = {power_value:.0f}W @ {ref_rpm:.0f} RPM', 
                          xy=(ref_rpm, power_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('RPM')
        ax.set_ylabel('Shaft Power (W)')
        ax.set_title('Shaft Power vs RPM')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        return popt_power


class JSweepPlotter(BasePlotter):
    """Plotter for CT, CP, and Efficiency vs Advance Ratio (J) at a specific RPM."""
    
    def __init__(self, data, propeller_name, target_rpm):
        super().__init__(data, propeller_name)
        self.target_rpm = target_rpm
    
    def get_plot_filename(self):
        return f'propeller_j_sweep_{self.propeller_name}_{self.target_rpm}rpm.png'
    
    def create_plot(self, save_plot=False, output_dir=None, reference_j_values=None):
        """Create plots of CT vs J, CP vs J, and Efficiency vs J."""
        # Extract data for the target RPM across all flight speeds
        j_values = []
        ct_values = []
        cp_values = []
        eta_values = []
        
        for speed, speed_data in self.data.items():
            rpm_array = speed_data['rpm'].values
            # Find closest RPM in this speed's data
            rpm_diffs = np.abs(rpm_array - self.target_rpm)
            closest_idx = np.argmin(rpm_diffs)
            actual_rpm = rpm_array[closest_idx]
            
            # Only use data points within 5% of target RPM
            if abs(actual_rpm - self.target_rpm) / self.target_rpm < 0.05:
                j_values.append(speed_data['J'].values[closest_idx])
                ct_values.append(speed_data['CT'].values[closest_idx])
                cp_values.append(speed_data['CP'].values[closest_idx])
                eta_values.append(speed_data['eta'].values[closest_idx])
        
        if len(j_values) == 0:
            print(f"Error: No data found for RPM {self.target_rpm}")
            return
        
        # Convert to numpy arrays and sort by J
        sort_indices = np.argsort(j_values)
        j_values = np.array(j_values)[sort_indices]
        ct_values = np.array(ct_values)[sort_indices]
        cp_values = np.array(cp_values)[sort_indices]
        eta_values = np.array(eta_values)[sort_indices]
        
        print(f"Found {len(j_values)} data points for RPM ≈ {self.target_rpm}")
        print(f"J range: {j_values.min():.3f} to {j_values.max():.3f}")
        
        # Create figure
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))
        fig.suptitle(f'Propeller Characteristics: {self.propeller_name}\nRPM: {self.target_rpm}', 
                     fontsize=14, fontweight='bold')
        
        # Plot CT vs J
        self._plot_ct(ax1, j_values, ct_values, reference_j_values)
        
        # Plot CP vs J
        self._plot_cp(ax2, j_values, cp_values, reference_j_values)
        
        # Plot Efficiency vs J
        self._plot_efficiency(ax3, j_values, eta_values, reference_j_values)
        
        plt.tight_layout()
        self.save_or_show_plot(fig, save_plot, output_dir)
    
    def _plot_ct(self, ax, j_values, ct_values, reference_j_values):
        """Plot CT vs J."""
        ax.scatter(j_values, ct_values, alpha=0.8, color='blue', s=40, label='Data points')
        ax.plot(j_values, ct_values, 'b-', alpha=0.5, linewidth=1.5)
        
        if reference_j_values:
            valid_j = [j for j in reference_j_values if j_values.min() <= j <= j_values.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_j, (j_values.min(), j_values.max()))
            
            for ref_j, y_offset in label_offsets:
                # Interpolate CT value
                ct_value = np.interp(ref_j, j_values, ct_values)
                ax.axvline(x=ref_j, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'CT = {ct_value:.4f} @ J = {ref_j:.3f}', 
                          xy=(ref_j, ct_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('Advance Ratio (J)')
        ax.set_ylabel('Thrust Coefficient (CT)')
        ax.set_title('Thrust Coefficient vs Advance Ratio')
        ax.grid(True, alpha=0.3)
        ax.legend()
    
    def _plot_cp(self, ax, j_values, cp_values, reference_j_values):
        """Plot CP vs J."""
        ax.scatter(j_values, cp_values, alpha=0.8, color='green', s=40, label='Data points')
        ax.plot(j_values, cp_values, 'g-', alpha=0.5, linewidth=1.5)
        
        if reference_j_values:
            valid_j = [j for j in reference_j_values if j_values.min() <= j <= j_values.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_j, (j_values.min(), j_values.max()))
            
            for ref_j, y_offset in label_offsets:
                # Interpolate CP value
                cp_value = np.interp(ref_j, j_values, cp_values)
                ax.axvline(x=ref_j, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'CP = {cp_value:.4f} @ J = {ref_j:.3f}', 
                          xy=(ref_j, cp_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('Advance Ratio (J)')
        ax.set_ylabel('Power Coefficient (CP)')
        ax.set_title('Power Coefficient vs Advance Ratio')
        ax.grid(True, alpha=0.3)
        ax.legend()
    
    def _plot_efficiency(self, ax, j_values, eta_values, reference_j_values):
        """Plot Efficiency vs J."""
        ax.scatter(j_values, eta_values, alpha=0.8, color='orange', s=40, label='Data points')
        ax.plot(j_values, eta_values, 'orange', alpha=0.5, linewidth=1.5)
        
        if reference_j_values:
            valid_j = [j for j in reference_j_values if j_values.min() <= j <= j_values.max()]
            label_offsets = PlotUtilities.calculate_label_offsets(valid_j, (j_values.min(), j_values.max()))
            
            for ref_j, y_offset in label_offsets:
                # Interpolate efficiency value
                eta_value = np.interp(ref_j, j_values, eta_values)
                ax.axvline(x=ref_j, color='purple', linestyle='--', alpha=0.7)
                ax.annotate(f'η = {eta_value:.3f} @ J = {ref_j:.3f}', 
                          xy=(ref_j, eta_value), xytext=(10, y_offset), 
                          textcoords='offset points', fontsize=9, 
                          bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('Advance Ratio (J)')
        ax.set_ylabel('Efficiency (η)')
        ax.set_title('Propeller Efficiency vs Advance Ratio')
        ax.grid(True, alpha=0.3)
        ax.legend()


class InteractivePlotterCLI:
    """Interactive command-line interface for creating plots."""
    
    def __init__(self):
        self.data_manager = PropellerDataManager()
    
    def run(self):
        """Run the interactive CLI."""
        print("=== Propeller Characteristic Plotter ===\n")
        
        # Find available propellers
        available_propellers = self.data_manager.find_available_propellers()
        
        if not available_propellers:
            print("No propeller data files found in reformatted_data/full-characteristics/")
            return
        
        print("Available propellers:")
        for i, prop in enumerate(available_propellers, 1):
            print(f"  {i:2d}. {prop}")
        
        # Get propeller selection
        propeller_name = self._get_propeller_selection(available_propellers)
        
        # Load propeller data
        print(f"\nLoading data for propeller: {propeller_name}")
        data = self.data_manager.load_propeller_data(propeller_name)
        
        if data is None:
            print(f"Failed to load data for propeller {propeller_name}")
            return
        
        # Get plot type
        plot_type = self._get_plot_type()
        
        if plot_type == 'rpm':
            self._create_rpm_sweep_plot(data, propeller_name)
        elif plot_type == 'j':
            self._create_j_sweep_plot(data, propeller_name)
    
    def _get_propeller_selection(self, available_propellers):
        """Get propeller selection from user."""
        while True:
            try:
                selection = input(f"\nSelect propeller (1-{len(available_propellers)}) or enter name directly: ").strip()
                
                if selection.isdigit():
                    index = int(selection) - 1
                    if 0 <= index < len(available_propellers):
                        return available_propellers[index]
                    else:
                        print(f"Please enter a number between 1 and {len(available_propellers)}")
                        continue
                
                if selection in available_propellers:
                    return selection
                else:
                    matches = [prop for prop in available_propellers if selection.upper() in prop.upper()]
                    if len(matches) == 1:
                        print(f"Found match: {matches[0]}")
                        return matches[0]
                    elif len(matches) > 1:
                        print(f"Multiple matches found: {', '.join(matches)}")
                        print("Please be more specific.")
                    else:
                        print(f"Propeller '{selection}' not found. Available options listed above.")
                        
            except (ValueError, KeyboardInterrupt):
                print("Invalid input. Please try again.")
    
    def _get_plot_type(self):
        """Get plot type selection from user."""
        print("\nPlot type options:")
        print("  1. RPM Sweep - Thrust/Torque/Power vs RPM at specific flight speed")
        print("  2. J Sweep - CT/CP/Efficiency vs Advance Ratio at specific RPM")
        
        while True:
            try:
                selection = input("\nSelect plot type (1 or 2): ").strip()
                
                if selection == '1':
                    return 'rpm'
                elif selection == '2':
                    return 'j'
                else:
                    print("Please enter 1 or 2")
                    
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                exit(0)
    
    def _create_rpm_sweep_plot(self, data, propeller_name):
        """Create RPM sweep plot interactively."""
        # Get flight speed
        while True:
            try:
                flight_speed_input = input("Enter flight speed (0-100 m/s): ").strip()
                flight_speed = float(flight_speed_input)
                
                if 0 <= flight_speed <= 100:
                    if flight_speed == int(flight_speed):
                        flight_speed = int(flight_speed)
                    
                    if flight_speed not in data:
                        closest_speed = self.data_manager.find_closest_value(data, flight_speed)
                        print(f"⚠️  Warning: Flight speed {flight_speed} m/s not found in data.")
                        print(f"    Using closest available speed: {closest_speed} m/s")
                        flight_speed = closest_speed
                    
                    break
                else:
                    print("Flight speed must be between 0 and 100 m/s")
                    
            except ValueError:
                print("Please enter a valid number")
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                return
        
        # Get reference RPMs
        reference_rpms = self._get_reference_rpms()
        
        # Ask about saving
        save_plot = self._ask_save_plot()
        
        # Create plot
        print(f"Creating plots for {propeller_name} at {flight_speed} m/s...")
        plotter = RPMSweepPlotter(data, propeller_name, flight_speed)
        plotter.create_plot(save_plot=save_plot, reference_rpms=reference_rpms)
    
    def _create_j_sweep_plot(self, data, propeller_name):
        """Create J sweep plot interactively."""
        # Get available RPMs
        available_rpms = self.data_manager.get_available_rpms(data)
        print(f"\nAvailable RPM range: {min(available_rpms)} - {max(available_rpms)}")
        
        # Get target RPM
        while True:
            try:
                rpm_input = input(f"Enter target RPM ({min(available_rpms)}-{max(available_rpms)}): ").strip()
                target_rpm = float(rpm_input)
                
                if target_rpm == int(target_rpm):
                    target_rpm = int(target_rpm)
                
                if min(available_rpms) <= target_rpm <= max(available_rpms):
                    break
                else:
                    print(f"RPM must be between {min(available_rpms)} and {max(available_rpms)}")
                    
            except ValueError:
                print("Please enter a valid number")
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                return
        
        # Get reference J values
        reference_j = self._get_reference_j_values()
        
        # Ask about saving
        save_plot = self._ask_save_plot()
        
        # Create plot
        print(f"Creating J-sweep plots for {propeller_name} at {target_rpm} RPM...")
        plotter = JSweepPlotter(data, propeller_name, target_rpm)
        plotter.create_plot(save_plot=save_plot, reference_j_values=reference_j)
    
    def _get_reference_rpms(self):
        """Get reference RPMs from user."""
        while True:
            try:
                ref_input = input("\nEnter reference RPMs to mark on graphs (comma-separated, or press Enter to skip): ").strip()
                
                if not ref_input:
                    return []
                
                try:
                    rpm_strings = [s.strip() for s in ref_input.split(',')]
                    reference_rpms = [float(rpm) for rpm in rpm_strings if rpm]
                    
                    if reference_rpms:
                        print(f"Reference RPMs set: {', '.join(f'{rpm:.0f}' for rpm in reference_rpms)}")
                    return reference_rpms
                    
                except ValueError:
                    print("Please enter valid numbers separated by commas (e.g., 5000, 8500, 12000)")
                    continue
                    
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                exit(0)
    
    def _get_reference_j_values(self):
        """Get reference J values from user."""
        while True:
            try:
                ref_input = input("\nEnter reference J values to mark on graphs (comma-separated, or press Enter to skip): ").strip()
                
                if not ref_input:
                    return []
                
                try:
                    j_strings = [s.strip() for s in ref_input.split(',')]
                    reference_j = [float(j) for j in j_strings if j]
                    
                    if reference_j:
                        print(f"Reference J values set: {', '.join(f'{j:.3f}' for j in reference_j)}")
                    return reference_j
                    
                except ValueError:
                    print("Please enter valid numbers separated by commas (e.g., 0.3, 0.5, 0.7)")
                    continue
                    
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                exit(0)
    
    def _ask_save_plot(self):
        """Ask user if they want to save the plot."""
        while True:
            try:
                save_choice = input("Save plot to file? (y/n): ").strip().lower()
                if save_choice in ['y', 'yes']:
                    return True
                elif save_choice in ['n', 'no']:
                    return False
                else:
                    print("Please enter 'y' for yes or 'n' for no.")
            except KeyboardInterrupt:
                print("\nOperation cancelled.")
                exit(0)


# Backwards compatibility functions for programmatic use
def find_available_propellers():
    """Find all available propeller pickle files."""
    return PropellerDataManager.find_available_propellers()


def load_propeller_data(propeller_name):
    """Load propeller data from pickle file."""
    return PropellerDataManager.load_propeller_data(propeller_name)


def plot_characteristics(data, flight_speed, propeller_name, save_plot=False, output_dir=None, reference_rpms=None):
    """Create plots of Thrust vs RPM, Torque vs RPM, and Power vs RPM.
    
    Backwards compatibility function for existing code.
    """
    plotter = RPMSweepPlotter(data, propeller_name, flight_speed)
    plotter.create_plot(save_plot=save_plot, output_dir=output_dir, reference_rpms=reference_rpms)


def plot_j_sweep(data, target_rpm, propeller_name, save_plot=False, output_dir=None, reference_j_values=None):
    """Create plots of CT vs J, CP vs J, and Efficiency vs J.
    
    New function for J-sweep plotting.
    """
    plotter = JSweepPlotter(data, propeller_name, target_rpm)
    plotter.create_plot(save_plot=save_plot, output_dir=output_dir, reference_j_values=reference_j_values)


def main():
    """Main function to run the propeller characteristic plotter."""
    cli = InteractivePlotterCLI()
    cli.run()


if __name__ == "__main__":
    import sys
    
    # Check for help argument
    if len(sys.argv) > 1 and sys.argv[1] in ['-h', '--help', 'help']:
        print(__doc__)
        print("\nFor more detailed usage examples, see PLOTTER_USAGE.md")
        sys.exit(0)
    
    # Check if required directories exist
    if not os.path.exists('reformatted_data/full-characteristics'):
        print("Error: reformatted_data/full-characteristics directory not found.")
        print("Please run characteristic_generator.py first to generate the data files.")
        print("\nTo generate data, run:")
        print("  python characteristic_generator.py")
        sys.exit(1)
    else:
        try:
            main()
        except KeyboardInterrupt:
            print("\n\nOperation cancelled by user.")
            sys.exit(0)
        except Exception as e:
            print(f"\nAn error occurred: {e}")
            print("Please check your input and try again.")
            sys.exit(1)
