#!/usr/bin/env python3
"""
Propeller Characteristic Plotter

This script visualizes propeller performance characteristics by loading data from
pickle files generated by characteristic_generator.py and creating plots of 
Thrust vs RPM, Torque vs RPM, and Shaft Power vs RPM for a specified propeller and flight speed.

Usage:
    python char_plotter.py
    
The script will prompt for:
- Propeller identifier (e.g., D10P12B2TWE)
- Flight speed in m/s (0-100)
"""

import os
import pickle
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import glob
import re


def find_available_propellers():
    """Find all available propeller pickle files in the reformatted_data/full-characteristics directory."""
    pickle_files = glob.glob('reformatted_data/full-characteristics/APC_Prop_*.pickle')
    propellers = []
    for file in pickle_files:
        # Extract propeller name from filename
        filename = os.path.basename(file)
        prop_name = filename.replace('APC_Prop_', '').replace('.pickle', '')
        propellers.append(prop_name)
    return sorted(propellers)


def load_propeller_data(propeller_name):
    """Load propeller data from pickle file."""
    filename = f'reformatted_data/full-characteristics/APC_Prop_{propeller_name}.pickle'
    
    if not os.path.exists(filename):
        return None
    
    try:
        with open(filename, 'rb') as f:
            data = pickle.load(f)
        return data
    except Exception as e:
        print(f"Error loading data: {e}")
        return None


def find_closest_speed(data, target_speed):
    """Find the closest available speed if exact match is not found."""
    available_speeds = list(data.keys())
    closest_speed = min(available_speeds, key=lambda x: abs(x - target_speed))
    return closest_speed


def extract_propeller_diameter(propeller_name):
    """Extract propeller diameter in inches from propeller name.
    
    Args:
        propeller_name: Name like 'D10P12B2TWE' where D10 means 10 inch diameter
        
    Returns:
        float: Diameter in inches, or None if cannot be parsed
    """
    try:
        # Extract the part after 'D' and before 'P'
        if 'D' in propeller_name and 'P' in propeller_name:
            diameter_string = propeller_name.split('P')[0][1:]  # Remove 'D' prefix
            if '-' in diameter_string:
                # Handle cases like 'D4-5P' -> 4.5 inches
                diameter = float(diameter_string.replace('-', '.'))
            else:
                diameter = float(diameter_string)
            return diameter
    except (ValueError, IndexError):
        pass
    return None


def calculate_max_mechanical_rpm(diameter_inches):
    """Calculate maximum mechanical RPM for APC propellers.
    
    Args:
        diameter_inches: Propeller diameter in inches
        
    Returns:
        int: Maximum mechanical RPM
    """
    if diameter_inches and diameter_inches > 0:
        return int(190000 / diameter_inches)
    return None


def second_order_polynomial(x, a, b, c):
    """Second order polynomial function for curve fitting."""
    return a * x**2 + b * x + c


def calculate_label_offsets(valid_rpms, rpm_fit):
    """Calculate vertical offsets for reference RPM labels to prevent overlap."""
    if len(valid_rpms) <= 1:
        return [(rpm, 15) for rpm in valid_rpms]
    
    # Sort RPMs to calculate spacing
    sorted_rpms = sorted(valid_rpms)
    rpm_range = rpm_fit.max() - rpm_fit.min()
    label_offsets = []
    
    # Define offset levels for staggered positioning
    offset_levels = [15, 45, 75, 25, 55, 85]  # Multiple vertical levels
    
    # Calculate offsets considering both proximity and label length overlap
    for i, ref_rpm in enumerate(sorted_rpms):
        # Check for potential label overlap with previous labels
        needs_offset = False
        
        # Check distance to neighbors and potential text overlap
        if i > 0:
            prev_rpm = sorted_rpms[i-1]
            horizontal_distance = (ref_rpm - prev_rpm) / rpm_range
            
            # If RPMs are close OR if they could have overlapping labels
            # (labels extend ~100-150 pixels horizontally, estimate based on RPM range)
            label_overlap_threshold = 0.20  # Increased threshold for label length consideration
            
            if horizontal_distance < label_overlap_threshold:
                needs_offset = True
        
        # Also check next RPM for forward-looking positioning
        if i < len(sorted_rpms) - 1:
            next_rpm = sorted_rpms[i+1]
            horizontal_distance = (next_rpm - ref_rpm) / rpm_range
            
            if horizontal_distance < 0.20:  # Same threshold
                needs_offset = True
        
        # Assign offset level
        if needs_offset:
            # Use cycling pattern through multiple levels
            base_offset = offset_levels[i % len(offset_levels)]
        else:
            # Even isolated labels should avoid the baseline to prevent overlap
            # Use alternating levels for better visual distribution
            base_offset = offset_levels[i % 2]  # Alternate between first two levels
        
        label_offsets.append((ref_rpm, base_offset))
    
    return label_offsets


def plot_characteristics(data, flight_speed, propeller_name, save_plot=False, output_dir=None, reference_rpms=None):
    """Create plots of Thrust vs RPM, Torque vs RPM, and Power vs RPM.
    
    Args:
        data: Propeller data dictionary
        flight_speed: Flight speed in m/s
        propeller_name: Name of the propeller
        save_plot: If True, save plot to file instead of displaying
        output_dir: Directory to save plots (default: current directory)
        reference_rpms: List of RPM values to mark on the plots with interpolated values
    """
    # Get data for the specified flight speed
    speed_data = data[flight_speed]
    
    # Extract RPM, Thrust, Torque, and Power data
    rpm = speed_data['rpm'].values
    thrust = speed_data['T'].values  # Thrust in N
    torque = speed_data['Q'].values  # Torque in Nm
    power = speed_data['P'].values   # Power in W
    
    # Calculate maximum mechanical RPM for curve fitting
    diameter_inches = extract_propeller_diameter(propeller_name)
    max_mechanical_rpm = calculate_max_mechanical_rpm(diameter_inches)
    
    if max_mechanical_rpm:
        print(f"Propeller diameter: {diameter_inches} inches")
        print(f"Max mechanical RPM limit for curve fitting: {max_mechanical_rpm} RPM")
    
    # Filter data for curve fitting: exclude zero RPM, truncated zeros, and high RPM extrapolation
    
    # Find first positive thrust value (excludes truncated negative values set to zero)
    positive_thrust_indices = np.where((rpm > 0) & (thrust > 0))[0]
    
    if len(positive_thrust_indices) > 0:
        first_positive_idx = positive_thrust_indices[0]
        first_positive_rpm = rpm[first_positive_idx]
        print(f"First positive thrust at RPM: {first_positive_rpm} (index {first_positive_idx})")
        
        # Count truncated zeros (non-zero RPM with zero thrust before first positive)
        truncated_zeros = np.sum((rpm > 0) & (rpm < first_positive_rpm) & (thrust == 0))
        if truncated_zeros > 0:
            print(f"Excluding {truncated_zeros} truncated zero values (RPM 1000-{first_positive_rpm-1000:.0f})")
        
        if max_mechanical_rpm:
            # Use data points from first positive thrust up to max mechanical RPM for fitting
            fitting_mask = (rpm >= first_positive_rpm) & (rpm <= max_mechanical_rpm)
            print(f"Fitting data from {first_positive_rpm} RPM to {max_mechanical_rpm} RPM")
        else:
            # Fallback: use from first positive thrust to end
            fitting_mask = rpm >= first_positive_rpm
            print("Warning: Could not determine propeller diameter. Using data from first positive thrust onward.")
    else:
        # No positive thrust found - use all non-zero RPM data as fallback
        non_zero_mask = rpm > 0
        fitting_mask = non_zero_mask
        print("Warning: No positive thrust values found. Using all non-zero RPM data for fitting.")
    
    rpm_fit = rpm[fitting_mask]
    thrust_fit = thrust[fitting_mask]
    torque_fit = torque[fitting_mask]
    power_fit = power[fitting_mask]
    
    # Show fitting statistics
    fitting_points = np.sum(fitting_mask)
    total_points = len(rpm)
    print(f"Using {fitting_points}/{total_points} data points for curve fitting")
    
    # Create figure with three vertically stacked subplots
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))
    fig.suptitle(f'Propeller Characteristics: {propeller_name}\nFlight Speed: {flight_speed} m/s', 
                 fontsize=14, fontweight='bold')
    
    # Plot 1: Thrust vs RPM
    # We'll not display the zero-RPM point or truncated zeros (these are excluded from fitting)
    zero_rpm_mask = rpm == 0

    if len(positive_thrust_indices) > 0:
        first_positive_rpm = rpm[positive_thrust_indices[0]]
        fitted_data_mask = (rpm >= first_positive_rpm)
        if max_mechanical_rpm:
            fitted_data_mask = fitted_data_mask & (rpm <= max_mechanical_rpm)
            extrapolated_mask = rpm > max_mechanical_rpm
        else:
            extrapolated_mask = np.zeros_like(rpm, dtype=bool)

        # Truncated zeros: rpm>0, rpm < first_positive_rpm and thrust == 0
        truncated_mask = (rpm > 0) & (rpm < first_positive_rpm) & (thrust == 0)

        # Fitted data points (exclude truncated zeros and zero-RPM)
        display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
        if np.any(display_fitted_mask):
            if max_mechanical_rpm:
                ax1.scatter(rpm[display_fitted_mask], thrust[display_fitted_mask], alpha=0.8, color='blue', s=30,
                           label=f'Fitted data ({first_positive_rpm:.0f}-{max_mechanical_rpm} RPM)')
            else:
                ax1.scatter(rpm[display_fitted_mask], thrust[display_fitted_mask], alpha=0.8, color='blue', s=30,
                           label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')

        # Extrapolated data points (beyond max mechanical RPM) - show if present
        if max_mechanical_rpm and np.any(extrapolated_mask):
            ax1.scatter(rpm[extrapolated_mask], thrust[extrapolated_mask], alpha=0.5, color='lightblue', s=30,
                       label=f'Extrapolated data (>{max_mechanical_rpm} RPM)')
    else:
        # Fallback: show non-zero RPM points but exclude zero-RPM
        non_zero_mask = rpm > 0
        display_mask = non_zero_mask
        if np.any(display_mask):
            ax1.scatter(rpm[display_mask], thrust[display_mask], alpha=0.6, color='blue', s=30,
                       label='Data points')
    
    # Fit second order polynomial to thrust data
    popt_thrust = None
    try:
        if len(rpm_fit) > 3:  # Need at least 3 points for 2nd order fit
            popt_thrust, _ = curve_fit(second_order_polynomial, rpm_fit, thrust_fit)
            # Limit the plotted fit to the fitted RPM range to avoid extrapolating into truncated zeros
            rpm_smooth = np.linspace(rpm_fit.min(), rpm_fit.max(), 200)
            thrust_smooth = second_order_polynomial(rpm_smooth, *popt_thrust)
            ax1.plot(rpm_smooth, thrust_smooth, 'r-', linewidth=2, 
                    label=f'2nd Order Fit: T = {popt_thrust[0]:.2e}×RPM² + {popt_thrust[1]:.2e}×RPM + {popt_thrust[2]:.2f}')
    except Exception as e:
        print(f"Could not fit thrust curve: {e}")
    
    # Add reference RPM markers for thrust plot
    if reference_rpms and popt_thrust is not None:
        valid_rpms = [rpm for rpm in reference_rpms if rpm_fit.min() <= rpm <= rpm_fit.max()]
        label_offsets = calculate_label_offsets(valid_rpms, rpm_fit)
        
        # Draw markers and labels
        for ref_rpm, y_offset in label_offsets:
            # Interpolate thrust value from trendline
            thrust_value = second_order_polynomial(ref_rpm, *popt_thrust)
            ax1.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
            ax1.annotate(f'T = {thrust_value:.1f}N @ {ref_rpm:.0f} RPM', 
                       xy=(ref_rpm, thrust_value), xytext=(10, y_offset), 
                       textcoords='offset points', fontsize=9, 
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
    
    ax1.set_xlabel('RPM')
    ax1.set_ylabel('Thrust (N)')
    ax1.set_title('Thrust vs RPM')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    
    # Plot 2: Torque vs RPM
    if len(positive_thrust_indices) > 0:
        # Fitted torque data (exclude truncated zeros and zero-RPM)
        display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
        if np.any(display_fitted_mask):
            if max_mechanical_rpm:
                ax2.scatter(rpm[display_fitted_mask], torque[display_fitted_mask], alpha=0.8, color='green', s=30,
                           label=f'Fitted data ({first_positive_rpm:.0f}-{max_mechanical_rpm} RPM)')
            else:
                ax2.scatter(rpm[display_fitted_mask], torque[display_fitted_mask], alpha=0.8, color='green', s=30,
                           label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')

        # Extrapolated torque points
        if max_mechanical_rpm and np.any(extrapolated_mask):
            ax2.scatter(rpm[extrapolated_mask], torque[extrapolated_mask], alpha=0.5, color='lightgreen', s=30,
                       label=f'Extrapolated data (>{max_mechanical_rpm} RPM)')
    else:
        # Fallback: show non-zero RPM torque points
        non_zero_mask = rpm > 0
        if np.any(non_zero_mask):
            ax2.scatter(rpm[non_zero_mask], torque[non_zero_mask], alpha=0.6, color='green', s=30,
                       label='Data points')
    
    # Fit second order polynomial to torque data
    popt_torque = None
    try:
        if len(rpm_fit) > 3:  # Need at least 3 points for 2nd order fit
            popt_torque, _ = curve_fit(second_order_polynomial, rpm_fit, torque_fit)
            torque_smooth = second_order_polynomial(rpm_smooth, *popt_torque)
            ax2.plot(rpm_smooth, torque_smooth, 'r-', linewidth=2,
                    label=f'2nd Order Fit: Q = {popt_torque[0]:.2e}×RPM² + {popt_torque[1]:.2e}×RPM + {popt_torque[2]:.2f}')
    except Exception as e:
        print(f"Could not fit torque curve: {e}")
    
    # Add reference RPM markers for torque plot
    if reference_rpms and popt_torque is not None:
        valid_rpms = [rpm for rpm in reference_rpms if rpm_fit.min() <= rpm <= rpm_fit.max()]
        label_offsets = calculate_label_offsets(valid_rpms, rpm_fit)
        
        # Draw markers and labels
        for ref_rpm, y_offset in label_offsets:
            # Interpolate torque value from trendline
            torque_value = second_order_polynomial(ref_rpm, *popt_torque)
            ax2.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
            ax2.annotate(f'Q = {torque_value:.3f}Nm @ {ref_rpm:.0f} RPM', 
                       xy=(ref_rpm, torque_value), xytext=(10, y_offset), 
                       textcoords='offset points', fontsize=9, 
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
    
    ax2.set_xlabel('RPM')
    ax2.set_ylabel('Torque (Nm)')
    ax2.set_title('Torque vs RPM')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    
    # Plot 3: Power vs RPM
    if len(positive_thrust_indices) > 0:
        # Fitted power data (exclude truncated zeros and zero-RPM)
        display_fitted_mask = fitted_data_mask & (~truncated_mask) & (~zero_rpm_mask)
        if np.any(display_fitted_mask):
            if max_mechanical_rpm:
                ax3.scatter(rpm[display_fitted_mask], power[display_fitted_mask], alpha=0.8, color='orange', s=30,
                           label=f'Fitted data ({first_positive_rpm:.0f}-{max_mechanical_rpm} RPM)')
            else:
                ax3.scatter(rpm[display_fitted_mask], power[display_fitted_mask], alpha=0.8, color='orange', s=30,
                           label=f'Fitted data (≥{first_positive_rpm:.0f} RPM)')

        # Extrapolated power points
        if max_mechanical_rpm and np.any(extrapolated_mask):
            ax3.scatter(rpm[extrapolated_mask], power[extrapolated_mask], alpha=0.5, color='moccasin', s=30,
                       label=f'Extrapolated data (>{max_mechanical_rpm} RPM)')
    else:
        # Fallback: show non-zero RPM power points
        non_zero_mask = rpm > 0
        if np.any(non_zero_mask):
            ax3.scatter(rpm[non_zero_mask], power[non_zero_mask], alpha=0.6, color='orange', s=30,
                       label='Data points')
    
    # Fit second order polynomial to power data
    popt_power = None
    try:
        if len(rpm_fit) > 3:  # Need at least 3 points for 2nd order fit
            popt_power, _ = curve_fit(second_order_polynomial, rpm_fit, power_fit)
            power_smooth = second_order_polynomial(rpm_smooth, *popt_power)
            ax3.plot(rpm_smooth, power_smooth, 'r-', linewidth=2,
                    label=f'2nd Order Fit: P = {popt_power[0]:.2e}×RPM² + {popt_power[1]:.2e}×RPM + {popt_power[2]:.2f}')
    except Exception as e:
        print(f"Could not fit power curve: {e}")
    
    # Add reference RPM markers for power plot
    if reference_rpms and popt_power is not None:
        valid_rpms = [rpm for rpm in reference_rpms if rpm_fit.min() <= rpm <= rpm_fit.max()]
        label_offsets = calculate_label_offsets(valid_rpms, rpm_fit)
        
        # Draw markers and labels
        for ref_rpm, y_offset in label_offsets:
            # Interpolate power value from trendline
            power_value = second_order_polynomial(ref_rpm, *popt_power)
            ax3.axvline(x=ref_rpm, color='purple', linestyle='--', alpha=0.7)
            ax3.annotate(f'P = {power_value:.0f}W @ {ref_rpm:.0f} RPM', 
                       xy=(ref_rpm, power_value), xytext=(10, y_offset), 
                       textcoords='offset points', fontsize=9, 
                       bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))
    
    ax3.set_xlabel('RPM')
    ax3.set_ylabel('Shaft Power (W)')
    ax3.set_title('Shaft Power vs RPM')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    
    # Adjust layout to prevent overlap
    plt.tight_layout()
    
    # Save or show the plot
    if save_plot:
        # Use output_plots directory as default if no output_dir specified
        if output_dir is None:
            output_dir = 'output_plots'
        
        os.makedirs(output_dir, exist_ok=True)
        filename = f'propeller_characteristics_{propeller_name}_{flight_speed}ms.png'
        filepath = os.path.join(output_dir, filename)
        
        plt.savefig(filepath, dpi=150, bbox_inches='tight')
        print(f"Plot saved as: {filepath}")
        plt.close()
    else:
        # Show the plot
        plt.show()


def main():
    """Main function to run the propeller characteristic plotter."""
    print("=== Propeller Characteristic Plotter ===\n")
    
    # Find available propellers
    available_propellers = find_available_propellers()
    
    if not available_propellers:
        print("No propeller data files found in reformatted_data/full-characteristics/")
        return
    
    print("Available propellers:")
    for i, prop in enumerate(available_propellers, 1):
        print(f"  {i:2d}. {prop}")
    
    # Get user input for propeller selection
    while True:
        try:
            selection = input(f"\nSelect propeller (1-{len(available_propellers)}) or enter name directly: ").strip()
            
            # Check if it's a number (index selection)
            if selection.isdigit():
                index = int(selection) - 1
                if 0 <= index < len(available_propellers):
                    propeller_name = available_propellers[index]
                    break
                else:
                    print(f"Please enter a number between 1 and {len(available_propellers)}")
                    continue
            
            # Check if it's a direct propeller name
            if selection in available_propellers:
                propeller_name = selection
                break
            else:
                # Try to find a partial match
                matches = [prop for prop in available_propellers if selection.upper() in prop.upper()]
                if len(matches) == 1:
                    propeller_name = matches[0]
                    print(f"Found match: {propeller_name}")
                    break
                elif len(matches) > 1:
                    print(f"Multiple matches found: {', '.join(matches)}")
                    print("Please be more specific.")
                else:
                    print(f"Propeller '{selection}' not found. Available options listed above.")
                    
        except (ValueError, KeyboardInterrupt):
            print("Invalid input. Please try again.")
    
    # Load propeller data
    print(f"\nLoading data for propeller: {propeller_name}")
    data = load_propeller_data(propeller_name)
    
    if data is None:
        print(f"Failed to load data for propeller {propeller_name}")
        return
    
    # Get user input for flight speed
    while True:
        try:
            flight_speed_input = input("Enter flight speed (0-100 m/s): ").strip()
            flight_speed = float(flight_speed_input)
            
            if 0 <= flight_speed <= 100:
                # Convert to integer if it's a whole number
                if flight_speed == int(flight_speed):
                    flight_speed = int(flight_speed)
                
                # Check if exact speed is available
                if flight_speed not in data:
                    closest_speed = find_closest_speed(data, flight_speed)
                    print(f"⚠️  Warning: Flight speed {flight_speed} m/s not found in data.")
                    print(f"    Using closest available speed: {closest_speed} m/s")
                    flight_speed = closest_speed
                
                break
            else:
                print("Flight speed must be between 0 and 100 m/s")
                
        except ValueError:
            print("Please enter a valid number")
        except KeyboardInterrupt:
            print("\nOperation cancelled.")
            return
    
    # Ask user for optional reference RPMs
    reference_rpms = []
    while True:
        try:
            ref_input = input("\nEnter reference RPMs to mark on graphs (comma-separated, or press Enter to skip): ").strip()
            
            if not ref_input:  # User pressed Enter without input
                break
            
            # Parse comma-separated RPMs
            try:
                rpm_strings = [s.strip() for s in ref_input.split(',')]
                reference_rpms = [float(rpm) for rpm in rpm_strings if rpm]  # Convert to float, skip empty strings
                
                if reference_rpms:
                    print(f"Reference RPMs set: {', '.join(f'{rpm:.0f}' for rpm in reference_rpms)}")
                break
                
            except ValueError:
                print("Please enter valid numbers separated by commas (e.g., 5000, 8500, 12000)")
                continue
                
        except KeyboardInterrupt:
            print("\nOperation cancelled.")
            return
    
    # Ask user about saving the plot
    while True:
        try:
            save_choice = input("Save plot to file? (y/n): ").strip().lower()
            if save_choice in ['y', 'yes']:
                save_plot = True
                break
            elif save_choice in ['n', 'no']:
                save_plot = False
                break
            else:
                print("Please enter 'y' for yes or 'n' for no.")
        except KeyboardInterrupt:
            print("\nOperation cancelled.")
            return
    
    # Create and show the plots
    print(f"Creating plots for {propeller_name} at {flight_speed} m/s...")
    plot_characteristics(data, flight_speed, propeller_name, save_plot=save_plot, reference_rpms=reference_rpms)


if __name__ == "__main__":
    import sys
    
    # Check for help argument
    if len(sys.argv) > 1 and sys.argv[1] in ['-h', '--help', 'help']:
        print(__doc__)
        print("\nFor more detailed usage examples, see PLOTTER_USAGE.md")
        sys.exit(0)
    
    # Check if required directories exist
    if not os.path.exists('reformatted_data/full-characteristics'):
        print("Error: reformatted_data/full-characteristics directory not found.")
        print("Please run characteristic_generator.py first to generate the data files.")
        print("\nTo generate data, run:")
        print("  python characteristic_generator.py")
        sys.exit(1)
    else:
        try:
            main()
        except KeyboardInterrupt:
            print("\n\nOperation cancelled by user.")
            sys.exit(0)
        except Exception as e:
            print(f"\nAn error occurred: {e}")
            print("Please check your input and try again.")
            sys.exit(1)